import { Injectable, NotFoundException, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, LessThanOrEqual, MoreThanOrEqual } from 'typeorm';
import { Incident, IncidentType, IncidentStatus } from './entities/incident.entity';
import { QueryIncidentsDto, ResolveIncidentDto, CreateIncidentDto, UpdateIncidentDto } from './dto';
import { AuditService } from '../audit/audit.service';
import { AuditAction, AuditEntity } from '../audit/entities/audit-log.entity';
import { TimeEntriesService } from '../time-entries/time-entries.service';

@Injectable()
export class IncidentsService {
  constructor(
    @InjectRepository(Incident)
    private readonly incidentRepository: Repository<Incident>,
    private readonly auditService: AuditService,
    @Inject(forwardRef(() => TimeEntriesService))
    private readonly timeEntriesService: TimeEntriesService,
  ) {}

  /**
   * Creates a new incident record.
   */
  async create(dto: CreateIncidentDto): Promise<Incident> {
    const incident = new Incident();
    incident.userId = dto.userId;
    incident.type = dto.type;
    incident.description = dto.description;
    incident.incidentDate = new Date(dto.incidentDate);
    incident.originalEntryTimestamp = dto.originalEntryTimestamp ? new Date(dto.originalEntryTimestamp) : null;
    incident.autoGeneratedExitTimestamp = dto.autoGeneratedExitTimestamp ? new Date(dto.autoGeneratedExitTimestamp) : null;
    incident.relatedEntryId = dto.relatedEntryId || null;
    incident.autoGenerated = dto.autoGenerated ?? true;
    incident.status = IncidentStatus.PENDING;

    return this.incidentRepository.save(incident);
  }

  /**
   * Finds all incidents with optional filters.
   */
  async findAll(query: QueryIncidentsDto): Promise<{
    incidents: Incident[];
    total: number;
    pendingCount: number;
    resolvedToday: number;
  }> {
    const { userId, type, status, startDate, endDate, pendingAdminReview } = query;
    const page = query.page && query.page > 0 ? query.page : 1;
    const limit = query.limit && query.limit > 0 ? query.limit : 50;

    const queryBuilder = this.incidentRepository
      .createQueryBuilder('incident')
      .leftJoinAndSelect('incident.user', 'user')
      .leftJoinAndSelect('incident.relatedEntry', 'relatedEntry')
      .leftJoinAndSelect('incident.resolvedByUser', 'resolvedByUser');

    if (userId) {
      queryBuilder.andWhere('incident.userId = :userId', { userId });
    }

    if (type) {
      queryBuilder.andWhere('incident.type = :type', { type });
    }

    if (status) {
      queryBuilder.andWhere('incident.status = :status', { status });
    }

    if (pendingAdminReview !== undefined) {
      queryBuilder.andWhere('incident.pendingAdminReview = :pendingAdminReview', { pendingAdminReview });
    }

    if (startDate && endDate) {
      queryBuilder.andWhere('incident.incidentDate BETWEEN :startDate AND :endDate', {
        startDate: new Date(startDate),
        endDate: new Date(endDate),
      });
    } else if (startDate) {
      queryBuilder.andWhere('incident.incidentDate >= :startDate', {
        startDate: new Date(startDate),
      });
    } else if (endDate) {
      queryBuilder.andWhere('incident.incidentDate <= :endDate', {
        endDate: new Date(endDate),
      });
    }

    const [incidents, total] = await queryBuilder
      .orderBy('incident.createdAt', 'DESC')
      .skip((page - 1) * limit)
      .take(limit)
      .getManyAndCount();

    // Count pending incidents
    const pendingCount = await this.incidentRepository.count({
      where: { status: IncidentStatus.PENDING },
    });

    // Count resolved today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const resolvedToday = await this.incidentRepository.count({
      where: {
        status: IncidentStatus.RESOLVED,
        resolvedAt: MoreThanOrEqual(today),
      },
    });

    return { incidents, total, pendingCount, resolvedToday };
  }

  /**
   * Finds a single incident by ID.
   */
  async findOne(id: string): Promise<Incident> {
    const incident = await this.incidentRepository.findOne({
      where: { id },
      relations: ['user', 'relatedEntry', 'resolvedByUser'],
    });

    if (!incident) {
      throw new NotFoundException(`Incident with ID ${id} not found`);
    }

    return incident;
  }

  /**
   * Finds incidents by user ID.
   */
  async findByUser(userId: string): Promise<Incident[]> {
    return this.incidentRepository.find({
      where: { userId },
      relations: ['relatedEntry'],
      order: { createdAt: 'DESC' },
    });
  }

  /**
   * Resolves an incident.
   */
  async resolve(
    id: string,
    dto: ResolveIncidentDto,
    resolvedBy: string,
  ): Promise<Incident> {
    const incident = await this.findOne(id);
    const oldValue = { ...incident };

    incident.status = dto.status || IncidentStatus.RESOLVED;
    incident.resolutionNotes = dto.resolutionNotes || null;
    incident.resolvedBy = resolvedBy;
    incident.resolvedAt = new Date();

    const updatedIncident = await this.incidentRepository.save(incident);

    await this.auditService.log({
      userId: resolvedBy,
      action: AuditAction.UPDATE,
      entityType: AuditEntity.TIME_ENTRY,
      entityId: id,
      oldValue,
      newValue: updatedIncident,
      description: `Incident resolved: ${incident.type}`,
    });

    return updatedIncident;
  }

  /**
   * Edita una incidencia (admin)
   * 
   * Cuando se edita una incidencia de tipo auto_exit_missing con una hora real de salida,
   * se actualiza automáticamente el historial del usuario recalculando las horas trabajadas.
   */
  async updateIncident(
    id: string,
    dto: UpdateIncidentDto,
    updatedBy: string,
  ): Promise<Incident> {
    const incident = await this.findOne(id);
    const oldValue = { ...incident };
    let updated = false;
    let shouldRecalculateHistory = false;

    if (dto.autoGeneratedExitTimestamp) {
      incident.autoGeneratedExitTimestamp = new Date(dto.autoGeneratedExitTimestamp);
      updated = true;
    }
    if (dto.realExitTimestamp) {
      incident.realExitTimestamp = new Date(dto.realExitTimestamp);
      updated = true;
      // Marcar que debemos recalcular el historial
      if (incident.type === IncidentType.AUTO_EXIT_MISSING && incident.relatedEntryId) {
        shouldRecalculateHistory = true;
      }
    }
    if (dto.description) {
      incident.description = dto.description;
      updated = true;
    }
    if (dto.resolved !== undefined) {
      incident.status = dto.resolved ? IncidentStatus.RESOLVED : IncidentStatus.PENDING;
      incident.resolvedAt = dto.resolved ? (dto.resolvedAt ? new Date(dto.resolvedAt) : new Date()) : null;
      incident.resolvedBy = dto.resolved ? updatedBy : null;
      updated = true;
    }
    
    if (!updated) return incident;

    // Marcar que fue editado por un admin
    incident.editedByAdmin = true;
    incident.editedAt = new Date();
    incident.editedBy = updatedBy;

    // Si hay solicitud de corrección del usuario, marcarla como revisada
    if (incident.pendingAdminReview) {
      incident.pendingAdminReview = false;
    }

    const updatedIncident = await this.incidentRepository.save(incident);

    // Si se actualizó la hora de salida real, recalcular el historial
    if (shouldRecalculateHistory && incident.realExitTimestamp && incident.relatedEntryId) {
      await this.recalculateWorkHoursForIncident(updatedIncident);
    }

    await this.auditService.log({
      userId: updatedBy,
      action: AuditAction.UPDATE,
      entityType: AuditEntity.TIME_ENTRY,
      entityId: id,
      oldValue,
      newValue: updatedIncident,
      description: `Incident edited by admin${shouldRecalculateHistory ? ' with history recalculation' : ''}`,
    });

    return updatedIncident;
  }

  /**
   * Recalcula las horas trabajadas cuando se edita una incidencia de salida automática.
   * Crea o actualiza la entrada de salida correspondiente con la hora real proporcionada.
   */
  private async recalculateWorkHoursForIncident(incident: Incident): Promise<void> {
    if (!incident.realExitTimestamp || !incident.relatedEntryId) return;

    try {
      // Obtener la entrada original
      const entry = await this.timeEntriesService.findOne(incident.relatedEntryId);
      
      // Crear una nueva entrada de salida con la hora real
      await this.timeEntriesService.createClockOutForIncident(
        incident.userId,
        incident.realExitTimestamp,
        incident.relatedEntryId,
        `Salida corregida por administrador. Incidencia: ${incident.id}`
      );

      // Marcar la incidencia como que ya se procesó el recálculo
      incident.resolutionNotes = incident.resolutionNotes 
        ? `${incident.resolutionNotes}\n[Recálculo automático: entrada de salida creada con hora real]`
        : '[Recálculo automático: entrada de salida creada con hora real]';
      
      await this.incidentRepository.save(incident);
    } catch (error) {
      console.error('Error recalculating work hours for incident:', error);
      // No lanzamos el error para no interrumpir la edición de la incidencia
    }
  }

  /**
   * Solicitar corrección de una incidencia (usuario normal)
   */
  async requestCorrection(
    id: string,
    userId: string,
    requestedTime: Date,
    message: string,
  ): Promise<Incident> {
    const incident = await this.findOne(id);

    // Verificar que el usuario es el propietario
    if (incident.userId !== userId) {
      throw new Error('No tienes permiso para solicitar corrección de esta incidencia');
    }

    // Verificar que la incidencia está pendiente
    if (incident.status !== IncidentStatus.PENDING) {
      throw new Error('Solo se pueden solicitar correcciones de incidencias pendientes');
    }

    incident.userRequestedTime = requestedTime;
    incident.userMessage = message;
    incident.pendingAdminReview = true;
    incident.correctionRequestedAt = new Date();

    const updatedIncident = await this.incidentRepository.save(incident);

    await this.auditService.log({
      userId,
      action: AuditAction.UPDATE,
      entityType: AuditEntity.TIME_ENTRY,
      entityId: id,
      oldValue: { userRequestedTime: null, userMessage: null },
      newValue: { userRequestedTime: requestedTime, userMessage: message },
      description: `Correction requested by user for incident`,
    });

    return updatedIncident;
  }

  /**
   * Gets count of pending incidents.
   */
  async getPendingCount(): Promise<number> {
    return this.incidentRepository.count({
      where: { status: IncidentStatus.PENDING },
    });
  }

  /**
   * Gets pending incidents for a specific user.
   */
  async getUserPendingIncidents(userId: string): Promise<Incident[]> {
    return this.incidentRepository.find({
      where: {
        userId,
        status: IncidentStatus.PENDING,
      },
      relations: ['user', 'relatedEntry', 'resolvedByUser'],
      order: { createdAt: 'DESC' },
    });
  }

  /**
   * Gets yesterday's pending incidents for a specific user (for login alert).
   */
  async getYesterdayPendingIncidents(userId: string): Promise<Incident[]> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    return this.incidentRepository.find({
      where: {
        userId,
        status: IncidentStatus.PENDING,
        type: IncidentType.AUTO_EXIT_MISSING,
        incidentDate: yesterday,
      },
      relations: ['user', 'relatedEntry', 'resolvedByUser'],
      order: { createdAt: 'DESC' },
    });
  }

  /**
   * Gets all correction requests pending admin review (admin only).
   */
  async getPendingReviews(): Promise<{
    incidents: Incident[];
    total: number;
  }> {
    const incidents = await this.incidentRepository.find({
      where: {
        pendingAdminReview: true,
        status: IncidentStatus.PENDING,
      },
      relations: ['user', 'relatedEntry', 'resolvedByUser'],
      order: { correctionRequestedAt: 'DESC' },
    });

    return { incidents, total: incidents.length };
  }

  /**
   * Gets user's complete incident history (for history page).
   */
  async getMyHistory(userId: string): Promise<Incident[]> {
    return this.incidentRepository.find({
      where: { userId },
      relations: ['relatedEntry', 'resolvedByUser'],
      order: { incidentDate: 'DESC', createdAt: 'DESC' },
    });
  }

  /**
   * Checks if an incident already exists for a specific entry.
   */
  async existsForEntry(relatedEntryId: string, type: IncidentType): Promise<boolean> {
    const count = await this.incidentRepository.count({
      where: { relatedEntryId, type },
    });
    return count > 0;
  }

  /**
   * Creates an auto-exit incident for an incomplete workday.
   */
  async createAutoExitIncident(
    userId: string,
    entryId: string,
    entryTimestamp: Date,
    autoExitTimestamp: Date,
  ): Promise<Incident | null> {
    // Check if incident already exists for this entry
    const exists = await this.existsForEntry(entryId, IncidentType.AUTO_EXIT_MISSING);
    if (exists) {
      return null;
    }

    const incidentDate = new Date(entryTimestamp);
    incidentDate.setHours(0, 0, 0, 0);

    return this.create({
      userId,
      type: IncidentType.AUTO_EXIT_MISSING,
      description: 'Salida automática generada por fin de día (jornada incompleta)',
      incidentDate: incidentDate.toISOString(),
      originalEntryTimestamp: entryTimestamp.toISOString(),
      autoGeneratedExitTimestamp: autoExitTimestamp.toISOString(),
      relatedEntryId: entryId,
      autoGenerated: true,
    });
  }

  /**
   * Gets summary statistics for the admin dashboard.
   */
  async getStats(): Promise<{
    pendingCount: number;
    resolvedToday: number;
    totalThisMonth: number;
    byType: Record<string, number>;
  }> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);

    const pendingCount = await this.incidentRepository.count({
      where: { status: IncidentStatus.PENDING },
    });

    const resolvedToday = await this.incidentRepository.count({
      where: {
        status: IncidentStatus.RESOLVED,
        resolvedAt: Between(today, tomorrow),
      },
    });

    const totalThisMonth = await this.incidentRepository.count({
      where: {
        createdAt: MoreThanOrEqual(firstDayOfMonth),
      },
    });

    // Count by type
    const byTypeQuery = await this.incidentRepository
      .createQueryBuilder('incident')
      .select('incident.type', 'type')
      .addSelect('COUNT(*)', 'count')
      .where('incident.status = :status', { status: IncidentStatus.PENDING })
      .groupBy('incident.type')
      .getRawMany();

    const byType: Record<string, number> = {};
    for (const row of byTypeQuery) {
      byType[row.type] = parseInt(row.count, 10);
    }

    return {
      pendingCount,
      resolvedToday,
      totalThisMonth,
      byType,
    };
  }
}
